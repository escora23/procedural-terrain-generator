# üèîÔ∏è PrimeraVersio2023 - Procedural Terrain Generator

<div align="center">

## üì¶ ARCHIVOS ORIGINALES - VERSI√ìN 1.0 (2023-2024)

**Trabajo Final de Bachillerato**

Creado por: **Jan Boncompte** y **Elena Hermoso**

---

</div>

## üìÑ ESTRUCTURA DE ARCHIVOS ORIGINALES

### Archivo 1: **index.html**

```html
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Generador de Monta√±as</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #111;
      color: #fff;
      text-align: center;
      padding-top: 50px;
    }

    h1 {
      font-size: 30px;
      margin-bottom: 20px;
      line-height: 1.2;
      color: #ddd;
      text-shadow: 2px 2px 4px #000;
    }

    .container {
      height: 500px;
      width: 600px;
      margin: 0 auto;
    }

    input[type="text"] {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      margin-bottom: 20px;
      background-color: #222;
      color: #fff;
    }

    button {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      background-color: #222;
      color: #fff;
      cursor: pointer;
      position: relative;
      animation: neon-glow 3s linear infinite;
      margin-bottom: 15px;
    }

    @keyframes neon-glow {
      0% {
        box-shadow: 0 0 10px #ff00ff, 0 0 10px #00ff00, 0 0 10px
#00ffff, 0 0 10px #ff9900, 0 0 10px #ff00ff;
      }
      25% {
        box-shadow: 0 0 10px #ff00ff, 0 0 10px #00ff00, 0 0 10px
#00ffff, 0 0 10px #ff9900, 0 0 10px #ff00ff;
      }
      50% {
        box-shadow: 0 0 10px #ff9900, 0 0 10px #ff00ff, 0 0 10px
#00ff00, 0 0 10px #00ffff, 0 0 10px #ff9900;
      }
      75% {
        box-shadow: 0 0 10px #ff9900, 0 0 10px #ff00ff, 0 0 10px
#00ff00, 0 0 10px #00ffff, 0 0 10px #ff9900;
      }
      100% {
        box-shadow: 0 0 10px #ff00ff, 0 0 10px #00ff00, 0 0 10px
#00ffff, 0 0 10px #ff9900, 0 0 10px #ff00ff;
      }
    }

    #canvas-container {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      width: 48%;
    }

    #canvas-container-small {
      width: 48%;
      display: flex;
      flex-direction: column;
    }

    #canvas2,
    #canvas3 {
      width: 100%;
      height: 200px;
      margin: 10px 0;
    }

    #voiceButton {
      position: absolute;
      top: 10px;
      right: 8px;
    }

    .rating {
      display: flex;
      flex-direction: row-reverse;
      font-size: 24px;
    }

    .rating > input {
      display: none;
    }

    .rating > label {
      position: relative;
      cursor: pointer;
    }

    .rating > label:before {
      content: '\2605';
      color: #ccc;
    }

    .rating > input:checked ~ label:before,
    .rating > label:hover ~ label:before,
    .rating > label:hover:before {
      color: #fdd835;
    }
  </style>
</head>
<body>
  <input type="text" id="mountainInput" placeholder="Preferencias de
Monta√±as (peque√±as o grandes)">
  <button onclick="generarLlanura(); generarOtrasLlanuras();">Generar
Llanura</button>


  <div id="canvas-container">
    <canvas id="canvas" style="position: absolute;"></canvas>
  </div>

  <button id="voiceButton">Iniciar Reconocimiento de Voz</button>
  <div id="voiceOutput"></div>
  <button onclick="confirmarConformidad();">Confirmar
Conformidad</button>
  <div class="rating">
    <input type="radio" id="star5" name="rating" value="5" /><label
for="star5" title="Excelente">5</label>
    <input type="radio" id="star4" name="rating" value="4" /><label
for="star4" title="Muy Bueno">4</label>
    <input type="radio" id="star3" name="rating" value="3" /><label
for="star3" title="Bueno">3</label>
    <input type="radio" id="star2" name="rating" value="2" /><label
for="star2" title="Regular">2</label>
    <input type="radio" id="star1" name="rating" value="1" /><label
for="star1" title="Malo">1</label>
  </div>
  <h1>Creat per Jan Boncompte i Elena Hermoso</h1>
  <script
src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"
 ></script>
  <script src="pruebas.js">
  </script>
</body>
</html>
```

---

### Archivo 2: **pruebas.js**

```javascript
// ============================================================================
// PERLIN NOISE - VERSI√ìN 1.0 (2023-2024)
// ============================================================================

var scene, camera, renderer;
var llanuraGroup;
var mouseDown = false;
var mouseX = 0,
  mouseY = 0;
var rotationSpeed = 0.01;
var llanuraGroup2, llanuraGroup3;

// ============================================================================
// CLASE: PERLIN NOISE B√ÅSICO
// ============================================================================

function PerlinNoise() {
  this.permutation = [
    151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7,
225,
    140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6,
148,
    247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11,
32,
    57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168,
68, 175,
    74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111,
229, 122,
    60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102,
143, 54,
    65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18,
169,
    200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173,
186, 3,
    64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255,
82, 85,
    212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223,
183, 170,
    213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167,
43, 172,
    9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178,
185, 112,
    104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191,
179,
    162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31,
181, 199,
    106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
138, 236,
    205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66,
215, 61,
    156, 180
  ];
  this.p = [];
  for (var i = 0; i < 256; i++) {
    this.p[256 + i] = this.p[i] = this.permutation[i];
  }
}

PerlinNoise.prototype.dot = function(g, x, y) {
  return g[0] * x + g[1] * y;
};

PerlinNoise.prototype.fade = function(t) {
  return t * t * t * (t * (t * 6 - 15) + 10);
};

PerlinNoise.prototype.lerp = function(t, a, b) {
  return a + t * (b - a);
};

PerlinNoise.prototype.grad = function(hash, x, y) {
  var h = hash & 7;
  var grad = [
    [1, 1],
    [-1, 1],
    [1, -1],
    [-1, -1],
    [1, 0],
    [-1, 0],
    [0, 1],
    [0, -1]
  ];
  return this.dot(grad[h], x, y);
};

PerlinNoise.prototype.noise = function(x, y) {
  var X = Math.floor(x) & 255;
  var Y = Math.floor(y) & 255;
  x -= Math.floor(x);
  y -= Math.floor(y);
  var fadeX = this.fade(x);
  var fadeY = this.fade(y);

  var A = this.p[X] + Y;
  var B = this.p[X + 1] + Y;

  var AA = this.p[A];
  var AB = this.p[A + 1];
  var BA = this.p[B];
  var BB = this.p[B + 1];

  var u = this.lerp(fadeX, this.grad(AA, x, y), this.grad(BA, x - 1, y));
  var v = this.lerp(fadeX, this.grad(AB, x, y - 1), this.grad(BB, x -
1, y - 1));

  return (this.lerp(fadeY, u, v) + 1) / 2;
};

PerlinNoise.prototype.generateNoise = function(width, height, scale) {
  var noiseData = [];
  var maxNoiseHeight = -Infinity;
  var minNoiseHeight = Infinity;

  for (var y = 0; y < height; y++) {
    noiseData[y] = [];
    for (var x = 0; x < width; x++) {
      var noise = this.noise(x / scale, y / scale);
      noiseData[y][x] = noise;
      if (noise > maxNoiseHeight) {
        maxNoiseHeight = noise;
      }
      if (noise < minNoiseHeight) {
        minNoiseHeight = noise;
      }
    }
  }

  // Normaliza los valores de ruido para que oscilen entre 0 y 1
  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      noiseData[y][x] = (noiseData[y][x] - minNoiseHeight) /
(maxNoiseHeight - minNoiseHeight);
    }
  }

  return noiseData;
};

// ============================================================================
// INICIALIZACI√ìN Y RENDERIZADO
// ============================================================================

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth /
window.innerHeight, 0.1, 1000);
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById("canvas-container").appendChild(renderer.domElement);

  // Crear nuevos renderizadores para las vistas adicionales
  renderer2 = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer2.setSize(window.innerWidth / 4, window.innerHeight / 4);
  document.getElementById("canvas-container").appendChild(renderer2.domElement);
  renderer2.domElement.style.position = "absolute";
  renderer2.domElement.style.top = "20";
  renderer2.domElement.style.right = "0";

  renderer3 = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer3.setSize(window.innerWidth / 4, window.innerHeight / 4);
  document.getElementById("canvas-container").appendChild(renderer3.domElement);
  renderer3.domElement.style.position = "absolute";
  renderer3.domElement.style.top = "100";
  renderer3.domElement.style.right = "1";

  document.addEventListener('mousedown', onMouseDown, false);
  document.addEventListener('mouseup', onMouseUp, false);
  document.addEventListener('mousemove', onMouseMove, false);
}

// ============================================================================
// CONTROL DEL MOUSE
// ============================================================================

function onMouseDown(event) {
  if (event.button === 0) {
    mouseDown = true;
    mouseX = event.clientX;
    mouseY = event.clientY;
  }
}

function onMouseUp(event) {
  if (event.button === 0) {
    mouseDown = false;
  }
}

function onMouseMove(event) {
  if (mouseDown) {
    var deltaX = event.clientX - mouseX;
    var deltaY = event.clientY - mouseY;
    llanuraGroup.rotation.y += deltaX * rotationSpeed;
    llanuraGroup.rotation.x += deltaY * rotationSpeed;
    mouseX = event.clientX;
    mouseY = event.clientY;
  }
}

// ============================================================================
// GENERACI√ìN DE LLANURA
// ============================================================================

function generarLlanura() {
  var seed = Math.floor(Math.random() * 1000);
  var perlin = new PerlinNoise(seed);

  var mountainInput = document.getElementById("mountainInput").value;
  var preferences = parseMountainPreferences(mountainInput);

  while (scene.children.length > 0) {
    scene.remove(scene.children[0]);
  }

  var seccionesX = 10;
  var seccionesZ = 10;

  var llanuraGeometry = new THREE.PlaneGeometry(100, 100, seccionesX,
seccionesZ);
  llanuraGeometry.rotateX(-Math.PI / 2);

  var colorMaterial = new THREE.MeshBasicMaterial({
    vertexColors: THREE.VertexColors
  });

  llanuraGroup = new THREE.Group();

  for (var i = 0; i <= seccionesX; i++) {
    for (var j = 0; j <= seccionesZ; j++) {
      var seccionGeometry = new THREE.PlaneGeometry(25, 25, 20, 20);

      seccionGeometry.rotateX(-Math.PI / 2);
      seccionGeometry.translate((i - seccionesX / 2) * 20, 0, (j -
seccionesZ / 2) * 20);
      var offsetX = Math.random() * 100;
      var offsetY = Math.random() * 100;

      var vertices = seccionGeometry.attributes.position.array;
      var colors = [];

      for (var k = 0; k < vertices.length; k += 3) {
        var x = vertices[k];
        var y = vertices[k + 1];
        var z = vertices[k + 2];

        var altura = perlin.noise((x + offsetX) / 10, (z + offsetY) /
10) * 10;

        var factorDeEscala = preferences.size === "peque√±as" ? 1 :
(preferences.size === "grandes" ? 5 : 3);
        altura *= factorDeEscala;

        var color = new THREE.Color(0x00FF00);
        var darkColor = new THREE.Color(0xFF0000);

        var t = (altura + 5) / 10;
        color.lerpHSL(darkColor, t);

        vertices[k + 1] = altura;
        colors.push(color.r, color.g, color.b);
      }

      seccionGeometry.setAttribute('color', new
THREE.Float32BufferAttribute(colors, 3));

      var seccionMesh = new THREE.Mesh(seccionGeometry, colorMaterial);
      llanuraGroup.add(seccionMesh);
    }
  }

  scene.add(llanuraGroup);
}

// ============================================================================
// AN√ÅLISIS DE PREFERENCIAS
// ============================================================================

function parseMountainPreferences(input) {
  var preferences = {
    size: "normales"
  };

  var words = input.toLowerCase().split(" ");
  if (words.includes("peque√±as")) {
    preferences.size = "peque√±as";
  } else if (words.includes("grandes")) {
    preferences.size = "grandes";
  }

  return preferences;
}

// ============================================================================
// RENDERIZADO
// ============================================================================

function render() {
  requestAnimationFrame(render);

  renderer.render(scene, camera);

  if (llanuraGroup2 && llanuraGroup2.userData && llanuraGroup2.userData.camera) {
    renderer2.render(scene, llanuraGroup2.userData.camera);
  }
  if (llanuraGroup3 && llanuraGroup3.userData && llanuraGroup3.userData.camera) {
    renderer3.render(scene, llanuraGroup3.userData.camera);
  }
}

// ============================================================================
// CONFIGURACI√ìN DE C√ÅMARA
// ============================================================================

function setupCamera() {
  var llanuraBoundingBox = new
THREE.Box3().setFromObject(llanuraGroup);
  var llanuraSize = llanuraBoundingBox.getSize(new THREE.Vector3());
  var llanuraCenter = llanuraBoundingBox.getCenter(new
THREE.Vector3());

  var distance = Math.max(llanuraSize.x, llanuraSize.y, llanuraSize.z)
* 1.5;
  var cameraPosition = llanuraCenter.clone().add(new THREE.Vector3(0,
distance, distance));

  camera.position.copy(cameraPosition);
  camera.lookAt(llanuraCenter);

  setupCameraForView(llanuraGroup, 50);
}

function generarOtrasLlanuras() {
  llanuraGroup2 = llanuraGroup.clone();
  llanuraGroup3 = llanuraGroup.clone();

  scene.add(llanuraGroup2);
  scene.add(llanuraGroup3);

  setupCameraForView(llanuraGroup2, 100, false);
  setupCameraForView(llanuraGroup3, 150, true);

  if (llanuraGroup) {
    scene.remove(llanuraGroup);
  }
}

function setupCameraForView(llanuraGroup, distance, isVertical) {
  if (!llanuraGroup.userData) {
    llanuraGroup.userData = {};
  }

  var llanuraBoundingBox = new
THREE.Box3().setFromObject(llanuraGroup);
  var llanuraSize = llanuraBoundingBox.getSize(new THREE.Vector3());
  var llanuraCenter = llanuraBoundingBox.getCenter(new
THREE.Vector3());

  var cameraPosition;

  if (isVertical) {
    cameraPosition = llanuraCenter.clone().add(new THREE.Vector3(0,
distance, 0));
  } else {
    cameraPosition = llanuraCenter.clone().add(new
THREE.Vector3(distance, llanuraSize.y * 0.5, 0));
  }

  llanuraGroup.userData.camera = new THREE.PerspectiveCamera(75,
window.innerWidth / window.innerHeight, 0.1, 1000);
  llanuraGroup.userData.camera.position.copy(cameraPosition);
  llanuraGroup.userData.camera.lookAt(llanuraCenter);
}

// ============================================================================
// RECONOCIMIENTO DE VOZ
// ============================================================================

const recognition = new (window.SpeechRecognition ||
window.webkitSpeechRecognition)();
recognition.continuous = true;
recognition.interimResults = true;

const voiceButton = document.getElementById("voiceButton");
const voiceOutput = document.getElementById("voiceOutput");

voiceButton.addEventListener("click", () => {
  recognition.start();
});

recognition.onresult = (event) => {
  const result = event.results[event.results.length - 1];
  const transcript = result[0].transcript;
  voiceOutput.innerHTML = `Has dicho: ${transcript}`;
  processVoiceCommand(transcript);
};

recognition.onend = () => {
  recognition.start();
};

function processVoiceCommand(transcript) {
  if (transcript.includes("generar llanura")) {
    generarLlanura();
  } else if (transcript.includes("generar monta√±as peque√±as")) {
    const input = document.getElementById("mountainInput");
    input.value = "peque√±as";
    generarLlanura();
  } else if (transcript.includes("generar monta√±as grandes")) {
    const input = document.getElementById("mountainInput");
    input.value = "grandes";
    generarLlanura();
  }
}

// ============================================================================
// CONFIRMACI√ìN Y RATING
// ============================================================================

function confirmarConformidad() {
  var rating = obtenerRating();
  if (rating >= 4) {
    alert("¬°Gracias por tu valoraci√≥n! La llanura cumple con tus
expectativas.");
    generarLlanura();
  } else {
    alert("Lamentamos que la llanura no cumpla con tus expectativas.
Puedes realizar ajustes si lo deseas.");

    scene.remove(llanuraGroup2, llanuraGroup3);

    if (llanuraGroup.scaled) {
      llanuraGroup.scale.set(0.5, 0.5, 0.5);
    } else {
      llanuraGroup.scale.set(2, 2, 2);
      llanuraGroup.scaled = true;
    }

    scene.add(llanuraGroup);
  }
}

function obtenerRating() {
  var ratingElements = document.getElementsByName("rating");
  for (var i = 0; i < ratingElements.length; i++) {
    if (ratingElements[i].checked) {
      return parseInt(ratingElements[i].value);
    }
  }
  return 0;
}

// ============================================================================
// INICIALIZACI√ìN PRINCIPAL
// ============================================================================

function setup() {
  init();
  generarLlanura();
  setupCamera();
  render();
}

window.onload = setup;
```

---

## üìä CARACTER√çSTICAS DE LA VERSI√ìN 1.0

### ‚úÖ Implementado
- ‚úì Perlin Noise b√°sico en 2D
- ‚úì Generaci√≥n de terreno procedural simple
- ‚úì M√∫ltiples vistas 3D (3 renderizadores)
- ‚úì Control del mouse para rotaci√≥n
- ‚úì Reconocimiento de voz
- ‚úì Sistema de preferencias (peque√±as/grandes)
- ‚úì Sistema de valoraci√≥n con estrellas
- ‚úì Interpolaci√≥n de colores (Verde ‚Üí Rojo)

### ‚ö†Ô∏è Limitaciones
- ‚ùå Sin fBm (Fractal Brownian Motion)
- ‚ùå Sin Ridge Noise
- ‚ùå Sin Cellular Noise
- ‚ùå Solo 1 escala de ruido
- ‚ùå Interfaz b√°sica
- ‚ùå Sin optimizaciones de rendimiento
- ‚ùå Funciones no definidas (setupCameraX, setupCameraY)
- ‚ùå Duplicaci√≥n de c√≥digo de voz

---

## üîÑ COMPARATIVA: v1.0 vs v2.0

| Aspecto | v1.0 (2023-2024) | v2.0 (2025) |
|---------|------------------|------------|
| **Perlin Noise** | B√°sico | Avanzado |
| **Algoritmos** | 1 (Basic) | 4 (fBm, Ridge, Cellular, 3D) |
| **Tipos de Terrain** | 1 (Llanura) | 5 (Muntanyes, Turons, Planures, Illes, Valls) |
| **L√≠neas de C√≥digo** | ~400 | 1000+ |
| **Interfaz** | Simple | Neon Profesional |
| **Funciones** | 20 | 40+ |
| **Optimizaci√≥n** | B√°sica | Avanzada |
| **Caracter√≠sticas** | Voz + Rating | Voz + Stats + Rating |

---

## üìù NOTAS IMPORTANTES

### C√≥digo Limpio
- El c√≥digo est√° correctamente formateado
- Bien estructurado con comentarios
- F√°cil de entender

### Archivos Necesarios
1. **index.html** - Interfaz y estructura
2. **pruebas.js** - L√≥gica de generaci√≥n (incluido en HTML con `<script>` tag)

### Para Usar
```bash
1. Guarda el HTML como index.html
2. Guarda el JavaScript como pruebas.js (o incluye en HTML)
3. Abre index.html en navegador
4. ¬°Genera terrenos!
```

---

## üéì VALOR EDUCATIVO

Este c√≥digo muestra:
- Implementaci√≥n b√°sica de Perlin Noise
- Uso de Three.js para 3D
- WebGL Rendering
- Web Speech API
- Manipulaci√≥n de eventos del mouse
- Generaci√≥n procedural simple

---

<div align="center">

## üèÜ TRABAJO FINAL DE BACHILLERATO 2023-2024

**Autores:** Jan Boncompte & Elena Hermoso

**Versi√≥n:** 1.0 Original

**Tecnolog√≠as:** HTML5, JavaScript, Three.js

**Estado:** Archivado (Mejorado en v2.0)

---

*Este fue el punto de partida para la versi√≥n 2.0 profesional*

</div>
